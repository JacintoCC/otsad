% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oip_sd_ewma.R
\name{OipSdEwma}
\alias{OipSdEwma}
\title{Optimized Incremental Processing Shift-Detection based on EWMA (SD-EWMA).}
\usage{
OipSdEwma(data, n.train, threshold, l = 3, last.res = NULL)
}
\arguments{
\item{data}{Numerical vector that conforms the training and test data set.}

\item{n.train}{Number of points of the data set that correspond to the
training set.}

\item{threshold}{Error threshold.}

\item{l}{Sigma multiplier to calculate the control limits.}

\item{last.res}{Last result returned by the algorithm.}
}
\value{
A list of the following items.

  \item{result}{Data set conformed by the following columns.}
  \itemize{
     \item \code{is.anomaly} 1 if the value is anomalous 0 otherwise.
     \item \code{ucl} Upper control limit.
     \item \code{lcl} Lower control limit.
 }
 \item{last.res}{Last result returned by the algorithm. Is a data set
 containing the parameters calculated in the last iteration and necessary
 for the next one.}
}
\description{
\code{OipSdEwma} is the optimized implementation of the \code{IpSdEwma}
function using environment variables. This function  allows you to calculate
anomalies using SD-EWMA alogrithm in an incremental processing mode. It has
been shown that in long data sets it can reduce runtime by up to 50\%.
}
\details{
SD-EWMA algorithm is a novel method for covariate shift-detection tests based
on a two-stage structure for univariate time-series. It works in an online
mode and it uses an exponentially weighted moving average (EWMA) model based
control chart to detect the covariate shift-point in non-stationary
time-series.

\code{data} must be numerical vectors without NA values.
\code{threshold} must be a numeric value between 0 and 1. It is recommended
to use low values such as 0.01 or 0.05. By default, 0.01 is used. \code{l} is
the parameter that determines the control limits. By default, 3 is used.
Finally \code{last.res} is the last result returned by some previous
execution of this algorithm. The first time the algorithm is executed its
value is NULL. However, if you want to run a new batch of data without having
to include it in the old data set and restart the process you only need to
add the last results returned by the last run.

This algorithm can be used for both classical and incremental processing. It
should be noted that in case of having a finite data set the
\code{\link{CpSdEwma}} or \code{\link{OcpSdEwma}} algorithms are faster.
Incremental processing can be used in two ways. 1) Processing all available
data and saving \code{last.res} for future runs in which you have new data.
2) Using the \href{https://CRAN.R-project.org/package=stream}{stream} library
for when you have too much data and it does not fit into memory. An example
has been made for this use case.
}
\examples{
## EXAMPLE 1: ----------------------
## You can use it in the same way as in CpSdEwma passing the whole dataset as
## an argument.

## Generate data
set.seed(100)
n <- 500
x <- sample(1:100, n, replace = TRUE)
x[70:90] <- sample(110:115, 21, replace = TRUE)
x[25] <- 200
x[320] <- 170
df=data.frame(timestamp=1:n,value=x)

## Calculate anomalies
result <- OipSdEwma(
  data = df$value,
  n.train = 5,
  threshold = 0.01,
  l = 3
)
res <- cbind(df[6:n,], result$result)
rownames(res) <- 1:(n-5)

## Plot results
res <- res[1:500,]
y.limits <- c(-150,250)
plot(x = res$timestamp, y = res$value, type = "l", ylim = y.limits, xlab = "timestamp", ylab = "value", main = "PEWMA ANOMALY DETECTOR")
points(x = res[res$is.anomaly == 1, "timestamp"], y = res[res$is.anomaly == 1, "value"], pch=4, col="red", lwd = 2)
par(new=TRUE)
plot(x = res$timestamp, y = res$ucl, type="l", col="red", xaxt="n", ylim = y.limits, xlab = "", ylab = "")
par(new=TRUE)
plot(x = res$timestamp, y = res$lcl, type="l", col="red", xaxt="n", ylim = y.limits, xlab = "", ylab = "")

## EXAMPLE 2: ----------------------
## You can use it you can use it in an incremental way. This is an example using
## stream library. This library allows you to simulate streaming operation.

# install.packages("stream")
library("stream")

## Generate data
set.seed(100)
n <- 500
x <- sample(1:100, n, replace = TRUE)
x[70:90] <- sample(110:115, 21, replace = TRUE)
x[25] <- 200
x[320] <- 170
df=data.frame(timestamp=1:n,value=x)
dsd_df <- DSD_Memory(df)

## Initialize parameters for the loop
last.res <- NULL
res <- NULL
nread <- 100
numIter <- n\%/\%nread

## Calculate anomalies
for(i in 1:numIter) {
  # read new data
  newRow <- get_points(dsd_df, n = nread, outofpoints = "ignore")
  # calculate if it's an anomaly
  last.res <- OipSdEwma(
    data = newRow$value,
    n.train = 5,
    threshold = 0.01,
    l = 3,
    last.res = last.res$last.res
  )
  # prepare the result
  if(!is.null(last.res$result)){
    res <- rbind(res, cbind(newRow[(nread-nrow(last.res$result)+1):nread,], last.res$result))
  }
}
print(res)
# plot
n.train <- 5
rownames(res) <- 1:(n-n.train)
res <- res[1:500,]
y.limits <- c(-150,250)
plot(x = res$timestamp, y = res$value, type = "l", ylim = y.limits, xlab = "timestamp", ylab = "value", main = "PEWMA ANOMALY DETECTOR")
points(x = res[res$is.anomaly == 1, "timestamp"], y = res[res$is.anomaly == 1, "value"], pch=4, col="red", lwd = 2)
par(new=TRUE)
plot(x = res$timestamp, y = res$ucl, type="l", col="red", xaxt="n", ylim = y.limits, xlab = "", ylab = "")
par(new=TRUE)
plot(x = res$timestamp, y = res$lcl, type="l", col="red", xaxt="n", ylim = y.limits, xlab = "", ylab = "")


}
\references{
Raza, H., Prasad, G., & Li, Y. (03 de 2015). EWMA model based
shift-detection methods for detecting covariate shifts in non-stationary
environments. Pattern Recognition, 48(3), 659-669.
}
