% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ip_pewma.R
\name{IpPewma}
\alias{IpPewma}
\title{Incremental Processing Probabilistic-EWMA (PEWMA).}
\usage{
IpPewma(data, n.train = 5, alpha0 = 0.8, beta = 0, l = 3,
  last.res = NULL)
}
\arguments{
\item{data}{Numerical vector that conforms the training and test data set.}

\item{n.train}{Number of points of the data set that correspond to the
training set.}

\item{alpha0}{Maximal weighting parameter.}

\item{beta}{Weight placed on the probability of the given observation.}

\item{l}{Control limit multiplier.}

\item{last.res}{Last result returned by the algorithm.}
}
\value{
A list of the following items.

  \item{result}{Data set conformed by the following columns.}
  \itemize{
     \item \code{is.anomaly} 1 if the value is anomalous 0 otherwise.
     \item \code{ucl} Upper control limit.
     \item \code{lcl} Lower control limit.
 }
 \item{last.res}{Last result returned by the algorithm. Is a data set
 containing the parameters calculated in the last iteration and necessary
 for the next one.}
}
\description{
\code{IpPewma} allows you to calculate anomalies using PEWMA in
an incremental processing mode. See also \code{\link{OipPewma}} the optimized
and faster function of the same. This algorithm is probabilistic method of
EWMA which dynamically adjusts the parameterization based on the probability
of the given observation. This method produces dynamic, data-driven anomaly
thresholds which are robust to abrupt transient changes, yet quickly adjust
to long-term distributional shifts. See also \code{\link{OcpPewma}} the
optimized and faster function of the same.
}
\details{
\code{data} must be numerical vectors without NA values.
\code{alpha0} must be a numeric value where 0 < \code{alpha0} < 1. If a
faster adjustment to the initial shift is desirable, simply lowering Î± will
suffice. \code{beta} is the weight placed on the probability of the given
observation. it must be a numeric value where 0 \leq \code{beta} \leq. Note
that \code{beta} equals 0, PEWMA converges to a standard EWMA. Finally
\code{l} is the parameter that determines the control limits. By default, 3
is used. \code{last.res} is the last result returned by some previous
execution of this algorithm. The first time the algorithm is executed its
value is NULL. However, if you want to run a new batch of data without having
to include it in the old data set and restart the process you only need to
add the last results returned by the last run.

This algorithm can be used for both classical and incremental processing. It
should be noted that in case of having a finite data set the
\code{\link{CpPewma}} or \code{\link{OcpPEwma}} algorithms are faster.
Incremental processing can be used in two ways. 1) Processing all available
data and saving \code{last.res} for future runs in which you have new data.
2) Using the \href{https://CRAN.R-project.org/package=stream}{stream} library
for when you have too much data and it does not fit into memory. An example
has been made for this use case.
}
\examples{
## EXAMPLE 1: ----------------------
## You can use it in the same way as in CpSdEwma passing the whole dataset as
## an argument.

## Generate data
set.seed(100)
n <- 500
x <- sample(1:100, n, replace = TRUE)
x[70:90] <- sample(110:115, 21, replace = TRUE)
x[25] <- 200
x[320] <- 170
df=data.frame(timestamp=1:n,value=x)

## Calculate anomalies
result <- IpPewma(
  data = df$value,
  alpha0 = 0.8,
  beta = 0,
  n.train = 5,
  l = 3,
  last.res = NULL
)
res <- cbind(df, result$result)

## Plot results
y.limits <- c(-150,250)
plot(x = res$timestamp, y = res$value, type = "l", ylim = y.limits,
     xlab = "timestamp", ylab = "value", main = "PEWMA ANOMALY DETECTOR")
points(x = res[res$is.anomaly == 1, "timestamp"],
       y = res[res$is.anomaly == 1, "value"], pch=4, col="red", lwd = 2)
par(new=TRUE)
plot(x = res$timestamp, y = res$ucl, type="l", col="green", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")
par(new=TRUE)
plot(x = res$timestamp, y = res$lcl, type="l", col="green", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")

## EXAMPLE 2: ----------------------
## You can use it you can use it in an incremental way. This is an example using
## stream library. This library allows you to simulate streaming operation.

# install.packages("stream")
library("stream")

## Generate data
set.seed(100)
n <- 500
x <- sample(1:100, n, replace = TRUE)
x[70:90] <- sample(110:115, 21, replace = TRUE)
x[25] <- 200
x[320] <- 170
df=data.frame(timestamp=1:n,value=x)
dsd_df <- DSD_Memory(df)

## Initialize parameters for the loop
last.res <- NULL
res <- NULL
nread <- 100
numIter <- n\%/\%nread

## Calculate anomalies
for(i in 1:numIter) {
  # read new data
  newRow <- get_points(dsd_df, n = nread, outofpoints = "ignore")
  # calculate if it's an anomaly
  last.res <- IpPewma(
    data = newRow$value,
    n.train = 5,
    alpha0 = 0.8,
    beta = 0,
    l = 3,
    last.res = last.res$last.res
  )
  # prepare the result
  if(!is.null(last.res$result)){
    res <- rbind(res, cbind(newRow, last.res$result))
  }
}

## Plot results
res <- res[6:500,]
y.limits <- c(-150,250)
plot(x = res$timestamp, y = res$value, type = "l", ylim = y.limits,
     xlab = "timestamp", ylab = "value", main = "PEWMA ANOMALY DETECTOR")
points(x = res[res$is.anomaly == 1, "timestamp"],
       y = res[res$is.anomaly == 1, "value"], pch=4, col="red", lwd = 2)
par(new=TRUE)
plot(x = res$timestamp, y = res$ucl, type="l", col="green", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")
par(new=TRUE)
plot(x = res$timestamp, y = res$lcl, type="l", col="green", xaxt="n",
     ylim = y.limits, xlab = "", ylab = "")



}
\references{
M. Carter, Kevin y W. Streilein. Probabilistic reasoning for
streaming anomaly detection. 2012 IEEE Statistical Signal Processing Workshop
(SSP), pp. 377-380, Aug 2012.
}
